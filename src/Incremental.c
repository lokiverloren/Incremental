/* Incremental.c generated by valac 0.27.1, the Vala compiler
 * generated from Incremental.vala, do not modify */

/*
 * Inccremental.vala
 *
 * Incremental is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Incremental is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>


#define TYPE_INCREMENTAL (incremental_get_type ())
#define INCREMENTAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INCREMENTAL, Incremental))
#define INCREMENTAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INCREMENTAL, IncrementalClass))
#define IS_INCREMENTAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INCREMENTAL))
#define IS_INCREMENTAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INCREMENTAL))
#define INCREMENTAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INCREMENTAL, IncrementalClass))

typedef struct _Incremental Incremental;
typedef struct _IncrementalClass IncrementalClass;
typedef struct _IncrementalPrivate IncrementalPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _Incremental {
	GtkApplication parent_instance;
	IncrementalPrivate * priv;
	GtkFileChooserButton* file_button;
	GtkButton* terminal_button;
	gchar* AppName;
	gchar* Version;
};

struct _IncrementalClass {
	GtkApplicationClass parent_class;
};


static gpointer incremental_parent_class = NULL;

GType incremental_get_type (void) G_GNUC_CONST;
enum  {
	INCREMENTAL_DUMMY_PROPERTY
};
Incremental* incremental_new (void);
Incremental* incremental_construct (GType object_type);
static void incremental_real_activate (GApplication* base);
GtkHeaderBar* incremental_create_headerbar (Incremental* self);
GtkGrid* incremental_create_interface (Incremental* self);
GtkTreeView* incremental_create_treeview (Incremental* self);
gint incremental_main (gchar** args, int args_length1);
static void incremental_finalize (GObject* obj);


Incremental* incremental_construct (GType object_type) {
	Incremental * self = NULL;
	self = (Incremental*) g_object_new (object_type, "application-id", "org.agora.incremental", "flags", G_APPLICATION_FLAGS_NONE, NULL);
	return self;
}


Incremental* incremental_new (void) {
	return incremental_construct (TYPE_INCREMENTAL);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void incremental_real_activate (GApplication* base) {
	Incremental * self;
	GtkApplicationWindow* window = NULL;
	GtkApplicationWindow* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	GtkHeaderBar* _tmp7_ = NULL;
	GtkHeaderBar* _tmp8_ = NULL;
	GtkGrid* _tmp9_ = NULL;
	GtkGrid* _tmp10_ = NULL;
	self = (Incremental*) base;
	_tmp0_ = (GtkApplicationWindow*) gtk_application_window_new ((GtkApplication*) self);
	g_object_ref_sink (_tmp0_);
	window = _tmp0_;
	gtk_window_resize ((GtkWindow*) window, 800, 600);
	_tmp1_ = self->AppName;
	_tmp2_ = string_to_string (_tmp1_);
	_tmp3_ = self->Version;
	_tmp4_ = string_to_string (_tmp3_);
	_tmp5_ = g_strconcat (_tmp2_, " ", _tmp4_, NULL);
	_tmp6_ = _tmp5_;
	gtk_window_set_title ((GtkWindow*) window, _tmp6_);
	_g_free0 (_tmp6_);
	gtk_window_set_position ((GtkWindow*) window, GTK_WIN_POS_CENTER);
	_tmp7_ = incremental_create_headerbar (self);
	_tmp8_ = _tmp7_;
	gtk_window_set_titlebar ((GtkWindow*) window, (GtkWidget*) _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = incremental_create_interface (self);
	_tmp10_ = _tmp9_;
	gtk_container_add ((GtkContainer*) window, (GtkWidget*) _tmp10_);
	_g_object_unref0 (_tmp10_);
	gtk_widget_show_all ((GtkWidget*) window);
	_g_object_unref0 (window);
}


GtkHeaderBar* incremental_create_headerbar (Incremental* self) {
	GtkHeaderBar* result = NULL;
	GtkHeaderBar* headerbar = NULL;
	GtkHeaderBar* _tmp0_ = NULL;
	GtkBox* file_box = NULL;
	GtkBox* _tmp1_ = NULL;
	GtkButton* file_new = NULL;
	GtkButton* _tmp2_ = NULL;
	GtkFileChooserButton* _tmp3_ = NULL;
	GtkFileChooserButton* _tmp4_ = NULL;
	GtkButton* file_export = NULL;
	GtkButton* _tmp5_ = NULL;
	GtkFileChooserButton* _tmp6_ = NULL;
	GtkButton* hide_tree = NULL;
	GtkButton* _tmp7_ = NULL;
	GtkButton* tree_append = NULL;
	GtkButton* _tmp8_ = NULL;
	GtkButton* _tmp9_ = NULL;
	GtkButton* _tmp10_ = NULL;
	GtkButton* _tmp11_ = NULL;
	GtkButton* redo_button = NULL;
	GtkButton* _tmp12_ = NULL;
	GtkButton* undo_button = NULL;
	GtkButton* _tmp13_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkHeaderBar*) gtk_header_bar_new ();
	g_object_ref_sink (_tmp0_);
	headerbar = _tmp0_;
	_tmp1_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp1_);
	file_box = _tmp1_;
	_tmp2_ = (GtkButton*) gtk_button_new_from_icon_name ("document-new-symbolic", GTK_ICON_SIZE_BUTTON);
	g_object_ref_sink (_tmp2_);
	file_new = _tmp2_;
	gtk_widget_set_tooltip_text ((GtkWidget*) file_new, "New document");
	_tmp3_ = (GtkFileChooserButton*) gtk_file_chooser_button_new ("No file open", GTK_FILE_CHOOSER_ACTION_OPEN);
	g_object_ref_sink (_tmp3_);
	_g_object_unref0 (self->file_button);
	self->file_button = _tmp3_;
	_tmp4_ = self->file_button;
	gtk_widget_set_tooltip_text ((GtkWidget*) _tmp4_, "Open document");
	_tmp5_ = (GtkButton*) gtk_button_new_from_icon_name ("document-export-symbolic", GTK_ICON_SIZE_BUTTON);
	g_object_ref_sink (_tmp5_);
	file_export = _tmp5_;
	gtk_widget_set_tooltip_text ((GtkWidget*) file_export, "Export document");
	gtk_container_add ((GtkContainer*) file_box, (GtkWidget*) file_new);
	_tmp6_ = self->file_button;
	gtk_container_add ((GtkContainer*) file_box, (GtkWidget*) _tmp6_);
	gtk_container_add ((GtkContainer*) file_box, (GtkWidget*) file_export);
	gtk_header_bar_set_custom_title (headerbar, (GtkWidget*) file_box);
	gtk_header_bar_set_show_close_button (headerbar, TRUE);
	_tmp7_ = (GtkButton*) gtk_button_new_from_icon_name ("pane-hide-symbolic", GTK_ICON_SIZE_BUTTON);
	g_object_ref_sink (_tmp7_);
	hide_tree = _tmp7_;
	gtk_widget_set_tooltip_text ((GtkWidget*) hide_tree, "Hide tree");
	gtk_header_bar_pack_start (headerbar, (GtkWidget*) hide_tree);
	_tmp8_ = (GtkButton*) gtk_button_new_from_icon_name ("list-add-symbolic", GTK_ICON_SIZE_BUTTON);
	g_object_ref_sink (_tmp8_);
	tree_append = _tmp8_;
	gtk_widget_set_tooltip_text ((GtkWidget*) tree_append, "Append new item to tree");
	gtk_header_bar_pack_start (headerbar, (GtkWidget*) tree_append);
	_tmp9_ = (GtkButton*) gtk_button_new_from_icon_name ("utilities-terminal-symbolic", GTK_ICON_SIZE_BUTTON);
	g_object_ref_sink (_tmp9_);
	_g_object_unref0 (self->terminal_button);
	self->terminal_button = _tmp9_;
	_tmp10_ = self->terminal_button;
	gtk_widget_set_tooltip_text ((GtkWidget*) _tmp10_, "Pop up terminal");
	_tmp11_ = self->terminal_button;
	gtk_header_bar_pack_end (headerbar, (GtkWidget*) _tmp11_);
	_tmp12_ = (GtkButton*) gtk_button_new_from_icon_name ("edit-redo-symbolic", GTK_ICON_SIZE_BUTTON);
	g_object_ref_sink (_tmp12_);
	redo_button = _tmp12_;
	gtk_widget_set_tooltip_text ((GtkWidget*) redo_button, "Redo");
	gtk_header_bar_pack_end (headerbar, (GtkWidget*) redo_button);
	_tmp13_ = (GtkButton*) gtk_button_new_from_icon_name ("edit-undo-symbolic", GTK_ICON_SIZE_BUTTON);
	g_object_ref_sink (_tmp13_);
	undo_button = _tmp13_;
	gtk_widget_set_tooltip_text ((GtkWidget*) undo_button, "Undo");
	gtk_header_bar_pack_end (headerbar, (GtkWidget*) undo_button);
	result = headerbar;
	_g_object_unref0 (undo_button);
	_g_object_unref0 (redo_button);
	_g_object_unref0 (tree_append);
	_g_object_unref0 (hide_tree);
	_g_object_unref0 (file_export);
	_g_object_unref0 (file_new);
	_g_object_unref0 (file_box);
	return result;
}


GtkTreeView* incremental_create_treeview (Incremental* self) {
	GtkTreeView* result = NULL;
	GtkTreeView* treeview = NULL;
	GtkTreeView* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkTreeView*) gtk_tree_view_new ();
	g_object_ref_sink (_tmp0_);
	treeview = _tmp0_;
	result = treeview;
	return result;
}


GtkGrid* incremental_create_interface (Incremental* self) {
	GtkGrid* result = NULL;
	GtkGrid* grid = NULL;
	GtkGrid* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp0_);
	grid = _tmp0_;
	result = grid;
	return result;
}


gint incremental_main (gchar** args, int args_length1) {
	gint result = 0;
	Incremental* app = NULL;
	Incremental* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	gint _tmp2_ = 0;
	_tmp0_ = incremental_new ();
	app = _tmp0_;
	_tmp1_ = args;
	_tmp1__length1 = args_length1;
	_tmp2_ = g_application_run ((GApplication*) app, _tmp1__length1, _tmp1_);
	result = _tmp2_;
	_g_object_unref0 (app);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return incremental_main (argv, argc);
}


static void incremental_class_init (IncrementalClass * klass) {
	incremental_parent_class = g_type_class_peek_parent (klass);
	((GApplicationClass *) klass)->activate = incremental_real_activate;
	G_OBJECT_CLASS (klass)->finalize = incremental_finalize;
}


static void incremental_instance_init (Incremental * self) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	_tmp0_ = g_strdup ("Incremental");
	self->AppName = _tmp0_;
	_tmp1_ = g_strdup ("0.1");
	self->Version = _tmp1_;
}


static void incremental_finalize (GObject* obj) {
	Incremental * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INCREMENTAL, Incremental);
	_g_object_unref0 (self->file_button);
	_g_object_unref0 (self->terminal_button);
	_g_free0 (self->AppName);
	_g_free0 (self->Version);
	G_OBJECT_CLASS (incremental_parent_class)->finalize (obj);
}


GType incremental_get_type (void) {
	static volatile gsize incremental_type_id__volatile = 0;
	if (g_once_init_enter (&incremental_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IncrementalClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) incremental_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Incremental), 0, (GInstanceInitFunc) incremental_instance_init, NULL };
		GType incremental_type_id;
		incremental_type_id = g_type_register_static (gtk_application_get_type (), "Incremental", &g_define_type_info, 0);
		g_once_init_leave (&incremental_type_id__volatile, incremental_type_id);
	}
	return incremental_type_id__volatile;
}



